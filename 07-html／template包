## html/template 包

html/template 包是golang标准库的一部分。 我们可以用html/template来修改我们的编辑页面的布局，并且不需要修改之前的golang代码。
首先我们要导入html/template包，因为没有用到fmt包，所以不再导入fmt包。<br>
```go
import (
"html/template"
"io/ioutil"
"net/http"
)
```
我们来创建一个带有表单的html文件，新建edit.html文件，加入如下代码。
```html
<h1>Editing {{.Title}}</h1>
<form action="/save/{{.Title}}" method="POST">
<div><textarea name="body" rows="20" cols="80">{{printf "%s" .Body}}</textarea></div>
<div><input type="submit" value="Save"></div>
</form>
```
修改editHandler方法，使用模板，而不是硬编码来渲染页面。
```go
func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len("/edit/"):]
    p, err := loadPage(title)
    if err != nil {
        p = &Page{Title: title}
    }
    t, _ := template.ParseFiles("edit.html")
    t.Execute(w, p)
}
```
template.ParseFiles能够读取 edit.html 页面内容，并且返回一个 *template.Template指针。<br>

t.Execute方法执行模板,写入html字符流到http返回中. 模板中的 .Title 和 .Body 都会被p.Title 和 p.Body中内容替换掉。
模板的变量都是用两对花括号括起来，这样才不会被当做普通字符处理，我们也可以在模板中使用printf "%s" 来渲染变量中的值，printf "%s" .Body将会渲染一段字符串，而不是一段字节数据。
现在我们知道如何使用templates包工作了，现在我们创建我们的viewHandler来处理view.html页面。
```html
<h1>{{.Title}}</h1>

<p>[<a href="/edit/{{.Title}}">edit</a>]</p>

<div>{{printf "%s" .Body}}</div>
```
修改viewHandler如下
```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len("/view/"):]
    p, _ := loadPage(title)
    t, _ := template.ParseFiles("view.html")
    t.Execute(w, p)
}
```
注意：这里我们总是要渲染模板文件，那么我们可以那段代码剥离出来。
```go
func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    t, _ := template.ParseFiles(tmpl + ".html")
    t.Execute(w, p)
}
```
修改各个handler：
```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len("/view/"):]
    p, _ := loadPage(title)
    renderTemplate(w, "view", p)
}
```
```go
func editHandler(w http.ResponseWriter, r *http.Request) {
    title := r.URL.Path[len("/edit/"):]
    p, err := loadPage(title)
    if err != nil {
        p = &Page{Title: title}
    }
    renderTemplate(w, "edit", p)
}
```
