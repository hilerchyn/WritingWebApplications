## 模板缓存
这是一段效率非常低的代码，renderTemplate方法每次都调用一次ParseFiles来渲染模板页面，较好的做法应该是在初始化的时候调用ParseFiles一次渲染所有模板成一个单利的 *Template，这些我们在调用ExecuteTemplate就是非常跨速的获取一个特殊的页面了。<br>
首先我们创建一个全局的变量templates，并在初始化包的时候ParseFiles初始化模板文件。<br>
```go
var templates = template.Must(template.ParseFiles("edit.html", "view.html"))
```
template.Must方法是一个没有实际意义的包装方法，在template.ParseFiles出现错误的时候触发panic。<br>
ParseFiles的参数是模板文件的名字，我们模板数量非常多，那么参数可能非常长。<br>
我们修改renderTemplate方法，去调用templates.ExecuteTemplate来渲染我们的模板，根据我们的文件名字来渲染模板。
```go
func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
    err := templates.ExecuteTemplate(w, tmpl+".html", p)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
```
Note :这里模板名字是模板的文件名，需要加上模板的文件后缀 '.html'.
